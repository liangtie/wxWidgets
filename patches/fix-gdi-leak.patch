From a9c696fc165f5ad6e266864bb0d928f595739335 Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Mon, 15 Jul 2024 17:41:37 +0200
Subject: [PATCH 1/5] Add private functions to get the number of used Windows
 resources

This will be used in our own unit tests.

For now, don't make these Windows-only functions public, but perhaps
they could be documented and provided as part of the public API in the
future.
---
 include/wx/msw/private/resource_usage.h | 40 ++++++++++++++++++
 src/msw/utilsgui.cpp                    | 55 +++++++++++++++++++++++++
 2 files changed, 95 insertions(+)
 create mode 100644 include/wx/msw/private/resource_usage.h

diff --git a/include/wx/msw/private/resource_usage.h b/include/wx/msw/private/resource_usage.h
new file mode 100644
index 000000000000..dfb421dcbcfe
--- /dev/null
+++ b/include/wx/msw/private/resource_usage.h
@@ -0,0 +1,40 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:        wx/msw/private/gui_resources.h
+// Purpose:     Functions for getting GUI resources usage on Windows.
+// Author:      Vadim Zeitlin
+// Created:     2024-07-15
+// Copyright:   (c) 2024 Vadim Zeitlin <vadim@wxwidgets.org>
+// Licence:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_MSW_PRIVATE_GUI_RESOURCES_H_
+#define _WX_MSW_PRIVATE_GUI_RESOURCES_H_
+
+// ----------------------------------------------------------------------------
+// Get current or peak resources usage
+// ----------------------------------------------------------------------------
+
+// Simple struct contains the number of GDI and USER objects.
+struct wxGUIObjectUsage
+{
+    unsigned long numGDI = 0;
+    unsigned long numUSER = 0;
+
+    bool operator==(const wxGUIObjectUsage& other) const
+    {
+        return numGDI == other.numGDI && numUSER == other.numUSER;
+    }
+
+    bool operator!=(const wxGUIObjectUsage& other) const
+    {
+        return !(*this == other);
+    }
+};
+
+// Returns the number of GUI resources currently in use by this process.
+WXDLLIMPEXP_CORE wxGUIObjectUsage wxGetCurrentlyUsedResources();
+
+// Returns the highest number of GUI resources ever used by this process.
+WXDLLIMPEXP_CORE wxGUIObjectUsage wxGetMaxUsedResources();
+
+#endif // _WX_MSW_PRIVATE_GUI_RESOURCES_H_
diff --git a/src/msw/utilsgui.cpp b/src/msw/utilsgui.cpp
index 3d3f90404153..0ad50cc3bb9c 100644
--- a/src/msw/utilsgui.cpp
+++ b/src/msw/utilsgui.cpp
@@ -25,6 +25,8 @@
     #include "wx/utils.h"
 #endif //WX_PRECOMP
 
+#include "wx/msw/private/resource_usage.h"
+
 #include "wx/msw/private.h"     // includes <windows.h>
 
 #include "wx/msw/wrapwin.h"
@@ -250,3 +252,56 @@ extern bool wxEnableFileNameAutoComplete(HWND hwnd)
 
     return true;
 }
+
+// ----------------------------------------------------------------------------
+// GUI resources usage
+// ----------------------------------------------------------------------------
+
+namespace
+{
+
+// Common implementation of the public functions we provide.
+
+enum class UseType
+{
+    Current,
+    Peak
+};
+
+wxGUIObjectUsage wxGetUsedResources(UseType useType)
+{
+    DWORD flagsGDI = 0,
+          flagsUSER = 0;
+
+    switch ( useType )
+    {
+        case UseType::Current:
+            flagsGDI = GR_GDIOBJECTS;
+            flagsUSER = GR_USEROBJECTS;
+            break;
+
+        case UseType::Peak:
+            flagsGDI = GR_GDIOBJECTS_PEAK;
+            flagsUSER = GR_USEROBJECTS_PEAK;
+            break;
+    }
+
+    const auto hProcess = ::GetCurrentProcess();
+
+    return {
+            ::GetGuiResources(hProcess, flagsGDI),
+            ::GetGuiResources(hProcess, flagsUSER)
+           };
+}
+
+} // anonymous namespace
+
+wxGUIObjectUsage wxGetCurrentlyUsedResources()
+{
+    return wxGetUsedResources(UseType::Current);
+}
+
+wxGUIObjectUsage wxGetMaxUsedResources()
+{
+    return wxGetUsedResources(UseType::Peak);
+}

From 6286fc5ca040697a4fa6df5dc9c56006a57c285c Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Mon, 15 Jul 2024 17:47:35 +0200
Subject: [PATCH 2/5] Fix adding smaller bitmap versions to wxBitmapBundle

Smaller bitmap was inserted in a wrong place, resulting in the entries
array not being sorted by bitmap size any longer and completely breaking
the logic of GetBitmap() which relied on it being sorted.

In particular, this meant that we kept recreating smaller version of the
first bitmap in the bundle again and again when the function was called
for the bitmap of the same size, which resulted in unbounded resource
consumption and, eventually, a crash.

Fix this by inserting the bitmap in the right place and add a unit test
checking that the number of GDI objects remains more or less constant
even after creating a lot of bitmaps.

Closes #24703.
---
 src/common/bmpbndl.cpp       |  8 ++---
 tests/graphics/bmpbundle.cpp | 63 ++++++++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+), 4 deletions(-)

diff --git a/src/common/bmpbndl.cpp b/src/common/bmpbndl.cpp
index 1f0c303ffc37..4a4590321518 100644
--- a/src/common/bmpbndl.cpp
+++ b/src/common/bmpbndl.cpp
@@ -282,7 +282,7 @@ wxBitmap wxBitmapBundleImplSet::GetBitmap(const wxSize& size)
     // We use linear search instead if binary one because it's simpler and the
     // vector size is small enough (< 10) for it not to matter in practice.
     const size_t n = m_entries.size();
-    size_t lastSmaller = 0;
+    size_t nextBigger = 0;
     for ( size_t i = 0; i < n; ++i )
     {
         const Entry& entry = m_entries[i];
@@ -298,7 +298,7 @@ wxBitmap wxBitmapBundleImplSet::GetBitmap(const wxSize& size)
 
             if ( sizeThis.x < size.x )
             {
-                lastSmaller = i;
+                nextBigger = i + 1;
                 continue;
             }
 
@@ -310,7 +310,7 @@ wxBitmap wxBitmapBundleImplSet::GetBitmap(const wxSize& size)
         {
             // Don't rescale this one, we prefer to downscale rather than
             // upscale as it results in better-looking bitmaps.
-            lastSmaller = i;
+            nextBigger = i + 1;
             continue;
         }
 
@@ -320,7 +320,7 @@ wxBitmap wxBitmapBundleImplSet::GetBitmap(const wxSize& size)
             // next bigger bitmap, so rescale it to the desired size.
             const Entry entryNew(entry, size);
 
-            m_entries.insert(m_entries.begin() + lastSmaller + 1, entryNew);
+            m_entries.insert(m_entries.begin() + nextBigger, entryNew);
 
             return entryNew.bitmap;
         }

From a6203be954125947aa88fd1712af7eb5d755a907 Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Mon, 15 Jul 2024 23:05:46 +0200
Subject: [PATCH 3/5] Fix crash when copying wxBitmaps in wxMSW if DIB creation
 fails

This shouldn't normally happen, but if it does, e.g. because all the GDI
resources have been exhaused, we still shouldn't crash, so check for
this.

Also add a (disabled by default as it could be potentially dangerous to
run it) test checking that we don't crash in this case.

See #24703.
---
 src/msw/bitmap.cpp        |  8 ++++++--
 tests/graphics/bitmap.cpp | 31 +++++++++++++++++++++++++++++++
 2 files changed, 37 insertions(+), 2 deletions(-)

diff --git a/src/msw/bitmap.cpp b/src/msw/bitmap.cpp
index 5e8164071b22..23ea840ef5e1 100644
--- a/src/msw/bitmap.cpp
+++ b/src/msw/bitmap.cpp
@@ -242,8 +242,12 @@ wxBitmapRefData::wxBitmapRefData(const wxBitmapRefData& data)
             const int d = dib.GetDepth();
 
             wxDIB dibDst(w, h, d);
-            memcpy(dibDst.GetData(), dib.GetData(), wxDIB::GetLineSize(w, d)*h);
-            InitFromDIB(dibDst);
+            if ( dibDst.IsOk() )
+            {
+                memcpy(dibDst.GetData(), dib.GetData(), wxDIB::GetLineSize(w, d)*h);
+                InitFromDIB(dibDst);
+            }
+            //else: creating the DIB failed, we can't do anything about it here.
         }
         else
         {

From 778cbef150cd67ad64868cf5394b16847f497692 Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Tue, 16 Jul 2024 01:33:14 +0200
Subject: [PATCH 4/5] Fix compilation of wxGetUsedResources() with MSVS 2015

Initialize the returned object manually to fix compilation error.
---
 src/msw/utilsgui.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/msw/utilsgui.cpp b/src/msw/utilsgui.cpp
index 0ad50cc3bb9c..9bb5c961cafb 100644
--- a/src/msw/utilsgui.cpp
+++ b/src/msw/utilsgui.cpp
@@ -288,10 +288,10 @@ wxGUIObjectUsage wxGetUsedResources(UseType useType)
 
     const auto hProcess = ::GetCurrentProcess();
 
-    return {
-            ::GetGuiResources(hProcess, flagsGDI),
-            ::GetGuiResources(hProcess, flagsUSER)
-           };
+    wxGUIObjectUsage usage;
+    usage.numGDI = ::GetGuiResources(hProcess, flagsGDI);
+    usage.numUSER = ::GetGuiResources(hProcess, flagsUSER);
+    return usage;
 }
 
 } // anonymous namespace

From 31f59355a0b2938cae2137e30149e6391b6fab60 Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Tue, 16 Jul 2024 14:51:07 +0200
Subject: [PATCH 5/5] Really fix wxBitmapBundleImpl::GetIndexToUpscale() return
 value

The changes of 538eafc78b (Fix bug with wrong GetIndexToUpscale() return
value, 2022-06-03) were wrong but happened to work when there were no
down-scaled versions of the bitmap in the bundle.

But in general, we shouldn't use the previous index, but the index just
before the one with the most appropriate scale, so do this, and extend
the unit test to check for this scenario too -- previously it would fail
due to an assert failure when we tried to upscale a previously
downscaled bitmap.
---
 src/common/bmpbndl.cpp       | 8 +++-----
 tests/graphics/bmpbundle.cpp | 5 +++++
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/common/bmpbndl.cpp b/src/common/bmpbndl.cpp
index 4a4590321518..398ca71bb1cb 100644
--- a/src/common/bmpbndl.cpp
+++ b/src/common/bmpbndl.cpp
@@ -845,15 +845,13 @@ size_t wxBitmapBundleImpl::GetIndexToUpscale(const wxSize& size) const
     const wxSize sizeDef = GetDefaultSize();
     for ( size_t i = 0;; )
     {
-        // Save it before it's updated by GetNextAvailableScale().
-        size_t indexPrev = i;
-
         const double scaleThis = GetNextAvailableScale(i);
         if ( scaleThis == 0.0 )
             break;
 
-        // Only update it now, knowing that this index could have been used.
-        indexLast = indexPrev;
+        // Only update it now, knowing that the index was changed by
+        // GetNextAvailableScale() to be one beyond the actually used one.
+        indexLast = i - 1;
 
         const double scale = size.y / (sizeDef.y*scaleThis);
         if (wxRound(scale) == scale)
